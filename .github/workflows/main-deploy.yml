name: Build, Push Docker Image, Deploy to EC2

on:
  push:
    branches:
      - deploy
  pull_request:
    types:
      - closed  
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      branch:
        description: "Target branch"
        required: false
        default: "develop"
      git_hash:
        description: "Override Git commit hash"
        required: false
        default: ""

concurrency:
  group: ${{ github.workflow }}

jobs:
  # ONLY RUN JOB ON PR MERGE on MAIN OR DEVELOP BRANCH
  build-push-deploy:
    if: github.event.pull_request.merged == true || github.event_name == 'workflow_dispatch' || github.ref == 'refs/heads/deploy'
    runs-on: ubuntu-latest      

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1 # Fetch only the latest commit to speed up the process

      - name: Initialize Global Log File
        run: |
          echo "LOG_FILE=workflow.log" >> $GITHUB_ENV
          echo "Logging started" > workflow.log
      
      - name: Check for required secrets
        id: check_required_secrets_status
        run: |
          check() {
            if [ -z "$1" ]; then
              echo "$2 is EMPTY ‚ùå" | tee -a $LOG_FILE
              echo "passed=failure" >> $GITHUB_OUTPUT
            else
              echo "$2 is SET ‚úÖ"
            fi
          }
          check "${{ secrets.DOMAIN_NAME_STAG }}" "DOMAIN_NAME_STAG"
          check "${{ secrets.NAMESERVERS_STAG }}" "NAMESERVERS_STAG"
          check "${{ secrets.EC2_HOST_STAG }}" "EC2_HOST_STAG"
          check "${{ secrets.EC2_SSH_KEY_STAG }}" "EC2_SSH_KEY_STAG"
          check "${{ secrets.DATABASE_DIRECT_URL_STAG}}" "DATABASE_DIRECT_URL_STAG"
          check "${{ secrets.DOMAIN_NAME_PROD }}" "DOMAIN_NAME_PROD"
          check "${{ secrets.NAMESERVERS_PROD }}" "NAMESERVERS_PROD"
          check "${{ secrets.EC2_HOST_PROD }}" "EC2_HOST_PROD"
          check "${{ secrets.EC2_SSH_KEY_PROD }}" "EC2_SSH_KEY_PROD"
          check "${{ secrets.DATABASE_DIRECT_URL_PROD}}" "DATABASE_DIRECT_URL_PROD"
          check "${{ secrets.AWS_REGION }}" "AWS_REGION"
          check "${{ secrets.AWS_ACCESS_KEY_ID }}" "AWS_ACCESS_KEY_ID"
          check "${{ secrets.AWS_SECRET_ACCESS_KEY }}" "AWS_SECRET_ACCESS_KEY"
          check "${{ secrets.REPO_NAME }}" "REPO_NAME"
          check "${{ secrets.REPO_URL }}" "REPO_URL"
          check "${{ secrets.AWS_ACCOUNT_ID }}" "AWS_ACCOUNT_ID"
          check "${{ secrets.CERTBOT_EMAIL }}" "CERTBOT_EMAIL"
          check "${{ secrets.NEXTAUTH_SECRET }}" "NEXTAUTH_SECRET"
          check "${{ secrets.CALENDSO_ENCRYPTION_KEY }}" "CALENDSO_ENCRYPTION_KEY"
          check "${{ secrets.NEXT_PUBLIC_API_V2_URL }}" "NEXT_PUBLIC_API_V2_URL"
          check "${{ secrets.SENDGRID_API_KEY }}" "SENDGRID_API_KEY"
          check "${{ secrets.EMAIL_TO }}" "EMAIL_TO"
          check "${{ secrets.EMAIL_FROM }}" "EMAIL_FROM"
          
      # SETTING NECESSARY ENV VARIABLES
      - name: Extract Git commit hash
        if: ${{ steps.check_required_secrets_status.outputs.passed != 'failure' }}
        id: hash
        run: |
          if [ -n "${{ github.event.inputs.git_hash }}" ]; then
            hash="${{ github.event.inputs.git_hash }}"
          else
            hash="$(git rev-parse HEAD)"
          fi
          echo "GIT_HASH=$hash" >> $GITHUB_OUTPUT
        
      # BUILDING AND PUSHING DOCKER IMAGE
      - name: Set up Docker Buildx
        id: setup_docker
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS Credentials
        if: ${{ steps.setup_docker.outcome == 'success' }}
        uses: aws-actions/configure-aws-credentials@v1
        id: configure-aws
        continue-on-error: true
        with:
          aws-region: ${{ secrets.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Check AWS Configure status
        shell: bash
        run: |
          if [ "${{ steps.configure-aws.outcome }}" != "success" ]; then
            echo "[ERROR]: ‚ùå AWS Configure failed" >> "$LOG_FILE"
          else
            echo "[INFO]: ‚úÖ AWS Configure successful" >> "$LOG_FILE"
          fi

      - name: Login to Amazon ECR
        if: ${{ steps.configure-aws.outcome == 'success' && !(github.event_name == 'workflow_dispatch' && github.event.inputs.git_hash != '') }}
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
        continue-on-error: true

      - name: Check ECR login status
        shell: bash
        if: ${{ steps.configure-aws.outcome == 'success' && !(github.event_name == 'workflow_dispatch' && github.event.inputs.git_hash != '') }}
        run: |
          if [ "${{ steps.login-ecr.outcome }}" != "success" ]; then
            echo "[ERROR]: ‚ùå ECR login failed" >> "$LOG_FILE"
          else
            echo "[INFO]: ‚úÖ ECR login successful" >> "$LOG_FILE"
            echo "passed=success" >> $GITHUB_OUTPUT
          fi
      
      # Setting current branch name
      - name: Set branch name
        id: set_branch
        run: |
          BRANCH_NAME="${{ github.event.inputs.branch != '' && github.event.inputs.branch || github.ref_name }}"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: Set Docker tag suffix
        if: ${{ steps.login-ecr.outcome == 'success' && !(github.event_name == 'workflow_dispatch' && github.event.inputs.git_hash != '') }}
        id: tag
        run: |
          echo "tag_suffix=${{ steps.set_branch.outputs.branch_name == 'deploy' && 'latest-prod' || 'latest-stag' }}" >> $GITHUB_OUTPUT

      - name: Set dynamic key values for  DOMAIN_NAME , NAMESERVERS ,EC2_HOST ,EC2_SSH_KEY , DATABASE_URL
        id : key_values
        run: | 
          if [ "${{ steps.set_branch.outputs.branch_name }}" == "deploy" ]; then
            echo "DOMAIN_NAME=${{ secrets.DOMAIN_NAME_PROD }}" >> $GITHUB_OUTPUT
            echo "NAMESERVERS=${{ secrets.NAMESERVERS_PROD }}" >> $GITHUB_OUTPUT
            echo "EC2_HOST=${{ secrets.EC2_HOST_PROD }}" >> $GITHUB_OUTPUT
            echo "EC2_SSH_KEY=${{ secrets.EC2_SSH_PROD }}" >> $GITHUB_OUTPUT
            echo "DATABASE_URL=${{ secrets.DATABASE_DIRECT_URL_PROD}}" >> $GITHUB_OUTPUT
          else
            echo "DOMAIN_NAME=${{ secrets.DOMAIN_NAME_STAG }}" >> $GITHUB_OUTPUT
            echo "NAMESERVERS=${{ secrets.NAMESERVERS_STAG }}" >> $GITHUB_OUTPUT
            echo "EC2_HOST=${{ secrets.EC2_HOST_STAG }}" >> $GITHUB_OUTPUT
            echo "EC2_SSH_KEY=${{ secrets.EC2_SSH_KEY_STAG }}" >> $GITHUB_OUTPUT
            echo "DATABASE_URL=${{ secrets.DATABASE_DIRECT_URL_STAG}}" >> $GITHUB_OUTPUT
          fi

      - name: Build and Push Docker image
        if: ${{ steps.login-ecr.outcome == 'success' && !(github.event_name == 'workflow_dispatch' && github.event.inputs.git_hash != '') }}
        id: docker_build
        uses: docker/build-push-action@v5
        continue-on-error: true
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ secrets.REPO_NAME }}:${{ steps.hash.outputs.git_hash }}
            ${{ steps.login-ecr.outputs.registry }}/${{ secrets.REPO_NAME }}:${{ steps.tag.outputs.tag_suffix }}
          build-args: |
            NEXTAUTH_URL=${{ steps.key_values.outputs.DOMAIN_NAME }}
            NEXTAUTH_SECRET=${{ secrets.NEXTAUTH_SECRET }}
            CALENDSO_ENCRYPTION_KEY=${{ secrets.CALENDSO_ENCRYPTION_KEY }}
            NEXT_PUBLIC_WEBAPP_URL=${{ format('https://{0}', steps.key_values.outputs.DOMAIN_NAME) }}
            NEXT_PUBLIC_API_V2_URL=${{ secrets.NEXT_PUBLIC_API_V2_URL }}

      - name: Check Docker build status
        shell: bash
        id : check_docker_build_status
        if: ${{ steps.login-ecr.outcome == 'success' && !(github.event_name == 'workflow_dispatch' && github.event.inputs.git_hash != '') }}
        run: |
          if [ "${{ steps.docker_build.outcome }}" != "success" ]; then
            echo "[ERROR]: ‚ùå Docker build & push failed" >> "$LOG_FILE"
          else
            echo "[INFO]: ‚úÖ Docker build & push succeeded" >> "$LOG_FILE"
          fi

      - name: ROLLBACK CHECK
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.git_hash != '' }}
        run: |
          echo "[INFO]: ‚Ü©Ô∏è Rollback step: Skipping building docker images" >> "$LOG_FILE"

          
      # DEPLOYING TO EC2
      - name: SSH into EC2 and Deploy
        if: ${{ steps.docker_build.outcome == 'success' || (github.event_name == 'workflow_dispatch' && github.event.inputs.git_hash != '') }}
        uses: appleboy/ssh-action@v0.1.10
        id: ssh_deploy
        env:
          NAMESERVERS: ${{ steps.key_values.outputs.NAMESERVERS }}
          EC2_HOST: ${{ steps.key_values.outputs.EC2_HOST }}
          EC2_SSH_KEY: ${{ steps.key_values.outputs.EC2_SSH_KEY }}
          REPO_URL: ${{secrets.REPO_URL}}
          BRANCH_NAME: ${{ steps.set_branch.outputs.branch_name }}
          DATABASE_URL: ${{ steps.key_values.outputs.DATABASE_URL }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
          REPO_NAME: ${{ secrets.REPO_NAME }}
          CERTBOT_EMAIL: ${{ secrets.CERTBOT_EMAIL }}
          GIT_HASH: ${{ steps.hash.outputs.git_hash }}
          IS_ROLLBACK: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.git_hash != '' }}
        with:
          host: ${{ env.EC2_HOST }}
          username: "ubuntu"
          key: ${{ env.EC2_SSH_KEY }}
          command_timeout: 1500s # 25 minutes
          envs: NAMESERVERS, AWS_REGION,AWS_ACCESS_KEY_ID,AWS_SECRET_ACCESS_KEY,AWS_ACCOUNT_ID, AWS_ACCOUNT_ID, REPO_NAME, REPO_URL, BRANCH_NAME, CERTBOT_EMAIL, GIT_HASH ,IS_ROLLBACK
          script: |
            #!/bin/bash

            #Initialize log file 
            LOG_FILE="/home/ubuntu/deployment.log"
            : > "$LOG_FILE"

            # Function for logging with timestamp
            log_message() {
              local level=$1
              local message=$2
              echo "[VPC][$level] $message" >> "$LOG_FILE"
              # Echo to stdout for GitHub Actions logs
              echo "[$level] $message"
            }

            # Function to execute a command and check its status
            exec_command() {
              local command_name=$1
              shift
              local command_to_run="$1"

              log_message "INFO" "Executing: $command_name"
              log_message "DEBUG" "Command: $command_to_run"

              eval "$command_to_run"
              local status=$?

              if [ $status -ne 0 ]; then
                log_message "ERROR" "‚ùå $command_name failed with status $status"
                return 1
              else
                log_message "INFO" "‚úÖ $command_name completed successfully"
                return 0
              fi
            }

            log_message "INFO" "==== VPC LOGS ===="

            # Setting up onehash-cal repo locally and pulling the latest changes
            if [ ! -d "$HOME/onehash-cal" ]; then
              log_message "INFO" "Directory 'onehash-cal' does not exist. Cloning the repository."
              mkdir -p ~/onehash-cal
              cd ~/onehash-cal || { log_message "ERROR" "Failed to cd into ~/onehash-cal"; exit 1; }
              
              if ! exec_command "Git init" "git init"; then
                exit 1
              fi
              
              exec_command "Git sparse checkout setup" "git config core.sparseCheckout true"
              # PULLING ONLY THE "infra" DIRECTORY TO SAVE TIME/SPACE
              echo "infra/*" > .git/info/sparse-checkout

              # ADDING THE REMOTE REPO
              if ! exec_command "Git remote add" "git remote add origin ${{env.REPO_URL}}"; then
                exit 1
              fi
              
              # Fetch the branch explicitly rather than pull
              if ! exec_command "Git fetch" "git fetch origin ${{env.BRANCH_NAME}} --depth=1"; then
                exit 1
              fi
              
              if ! exec_command "Git checkout" "git checkout ${{env.BRANCH_NAME}}"; then
                exit 1
              fi
            else
              log_message "INFO" "Directory 'onehash-cal' exists. Pulling the latest changes."
              cd ~/onehash-cal || { log_message "ERROR" "Failed to cd into ~/onehash-cal"; exit 1; }
              
              # Fetch changes first to see what's new
              if ! exec_command "Git fetch" "git fetch origin ${{env.BRANCH_NAME}}"; then
                exit 1
              fi
              
              # Reset to the remote branch to avoid merge conflicts
              if ! exec_command "Git reset" "git reset --hard origin/${{env.BRANCH_NAME}}"; then
                exit 1
              fi
            fi

            # Set timeout for aws command to prevent hanging
            export AWS_CLI_TIMEOUT=60
            export AWS_SDK_TIMEOUT=60

            # Configure AWS credentials non-interactively
            log_message "INFO" "Configuring AWS credentials..."
            if ! exec_command "AWS Configure Access Key" "aws configure set aws_access_key_id \"${AWS_ACCESS_KEY_ID}\" >> \"$LOG_FILE\" 2>&1"; then
              log_message "ERROR" "Failed to configure AWS access key - exiting deployment"
              exit 1
            fi

            if ! exec_command "AWS Configure Secret Key" "aws configure set aws_secret_access_key \"${AWS_SECRET_ACCESS_KEY}\" >> \"$LOG_FILE\" 2>&1"; then
              log_message "ERROR" "Failed to configure AWS secret key - exiting deployment"
              exit 1
            fi

            if ! exec_command "AWS Configure Region" "aws configure set default.region \"${AWS_REGION}\" >> \"$LOG_FILE\" 2>&1"; then
              log_message "ERROR" "Failed to configure AWS region - exiting deployment"
              exit 1
            fi

            if ! exec_command "AWS Configure Output" "aws configure set default.output json >> \"$LOG_FILE\" 2>&1"; then
              log_message "ERROR" "Failed to configure AWS output format - exiting deployment"
              exit 1
            else
              log_message "INFO" "AWS credentials configured successfully."
            fi

            # Login to AWS ECR with timeout
            log_message "INFO" "Logging into AWS ECR..."
            if ! exec_command "AWS ECR Login" "timeout 60s aws ecr get-login-password --region \"${AWS_REGION}\" | timeout 60s docker login --username AWS --password-stdin \"${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com\" >> \"$LOG_FILE\" 2>&1"; then
              log_message "ERROR" "Failed to log into ECR - exiting deployment"
              exit 1
            else
              log_message "INFO" "Logged into ECR successfully."
            fi

            # Determine current and new ports
            PORT=$(sudo grep -oP '127.0.0.1:\K[0-9]+' /etc/nginx/conf.d/default.conf 2>/dev/null || echo "")
            if [ -z "$PORT" ]; then
              CURRENT_PORT=3002 # Default to 3002 if not found
            else
              CURRENT_PORT=$PORT
            fi
            log_message "INFO" "Current port: $CURRENT_PORT"

            # BLUE/GREEN DEPLOYMENT STRATEGY
            # Check the current port and switch to the other one
            if [ "$CURRENT_PORT" = "3001" ]; then
              NEW_PORT=3002
              CONTAINER_NAME=Green
              log_message "INFO" "Switching to port 3002(Green)"
            else
              NEW_PORT=3001
              CONTAINER_NAME=Blue
              log_message "INFO" "Switching to port 3001(Blue)"
            fi

            # Build the Docker image with the new port
            log_message "INFO" "Building Docker image with new port: $NEW_PORT"
            cd ~/onehash-cal/infra/docker/web || { log_message "ERROR" "Failed to cd into ~/onehash-cal/infra/docker/web"; exit 1; }

            if [ ! -d "$HOME/onehash-cal/infra/docker/web" ]; then
              log_message "ERROR" "Directory 'onehash-cal/infra/docker/web' does not exist. Exiting."
              exit 1
            fi

            # Stop and remove any existing container with the same name
            docker rm -f "$CONTAINER_NAME" >/dev/null 2>&1 || true
            log_message "INFO" "Removed any existing container with name $CONTAINER_NAME"

            #Running container
            log_message "INFO" "Starting Docker container '$CONTAINER_NAME' on port $NEW_PORT"

            AWS_ACCOUNT_ID=${{ env.AWS_ACCOUNT_ID }}
            AWS_REGION=${{ env.AWS_REGION }}
            REPO_NAME=${{ env.REPO_NAME }}
            DOCKER_IMAGE_TAG=${{ env.GIT_HASH }}
            IS_ROLLBACK=${{ env.IS_ROLLBACK}}

            if ! exec_command "Docker run" "docker run -d -it -e IS_ROLLBACK=\"$IS_ROLLBACK\" --name \"$CONTAINER_NAME\" --env-file \"$HOME/.env\" -p ${NEW_PORT}:3001 --add-host=host.docker.internal:host-gateway \"${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${REPO_NAME}:${DOCKER_IMAGE_TAG}\""; then
              log_message "ERROR" "‚ùå Failed to start Docker container '$CONTAINER_NAME' - aborting deployment"
              exit 1
            else
              log_message "INFO" "‚úÖ Docker container '$CONTAINER_NAME' started successfully on port $NEW_PORT"
            fi

            # HEALTH CHECK with progress tracking and better error handling
            log_message "INFO" "Starting health checks for application on port $NEW_PORT"
            HEALTH_CHECK_SUCCESS=false

            for i in {1..30}; do
              log_message "INFO" "Health check attempt $i/30"
              
              # Use timeout for curl to prevent hanging
              STATUS_CODE=$(timeout 10s curl -s -o /dev/null -w "%{http_code}" "http://localhost:${NEW_PORT}/api/health" || echo "FAILED")
              
              if [ "$STATUS_CODE" = "200" ]; then
                log_message "INFO" "‚úÖ Application is healthy! Status code: $STATUS_CODE"
                HEALTH_CHECK_SUCCESS=true
                break
              fi
              log_message "WARN" "‚è≥ Still waiting... Attempt $i/30 - Status code: $STATUS_CODE"
              sleep 30
            done
              
            if [ "$HEALTH_CHECK_SUCCESS" != "true" ]; then
              log_message "ERROR" "‚ùå Application did not become healthy after 30 attempts. Checking container logs..."
              docker logs "$CONTAINER_NAME" >> "$LOG_FILE" 2>&1
              log_message "ERROR" "Deployment failed - application didn't pass health checks"
              exit 1
            fi

            # NGINX configuration
            log_message "INFO" "Configuring NGINX"

            NGINX_CONF_PATH="/etc/nginx/conf.d/default.conf"
            TEMPLATE_PATH="$HOME/onehash-cal/infra/docker/web/nginx.template.conf"

            # Check if template exists
            if [ ! -f "$TEMPLATE_PATH" ]; then
              log_message "ERROR" "‚ùå NGINX template not found at $TEMPLATE_PATH"
              exit 1
            fi

            # Remove default site
            log_message "INFO" "Removing default NGINX site (if any)"
            if ! exec_command "Removing default site" "sudo rm -f /etc/nginx/sites-enabled/default"; then
              log_message "WARN" "‚ö†Ô∏è Could not remove default site, continuing anyway"
            fi

            # Copy template
            log_message "INFO" "Copying nginx template to $NGINX_CONF_PATH"
            if ! exec_command "Copy nginx config" "sudo cp -f \"$TEMPLATE_PATH\" \"$NGINX_CONF_PATH\""; then
              log_message "ERROR" "Failed to copy NGINX config template"
              exit 1
            fi

            # Replace placeholders
            log_message "INFO" "Replacing 'PORT_PLACEHOLDER' and 'DOMAIN_PLACEHOLDER'"
            if ! exec_command "Replace PORT" "sudo sed -i \"s/PORT_PLACEHOLDER/$NEW_PORT/g\" \"$NGINX_CONF_PATH\""; then
              exit 1
            fi

            if ! exec_command "Replace DOMAIN" "sudo sed -i \"s/DOMAIN_PLACEHOLDER/$NAMESERVERS/g\" \"$NGINX_CONF_PATH\""; then
              exit 1
            fi

            # # Test NGINX config
            # log_message "INFO" "Testing NGINX config before reload"
            # if ! exec_command "NGINX config test" "sudo nginx -t"; then
            #   log_message "ERROR" "NGINX configuration test failed"
            #   exit 1
            # fi

            # # Reload NGINX
            # log_message "INFO" "Reloading NGINX (pre-certbot)"
            # if ! exec_command "NGINX reload" "sudo nginx -s reload"; then
            #   exit 1
            # fi

            # SSL Certificate with certbot
            log_message "INFO" "Generating SSL cert for $NAMESERVERS"
            # Add a timeout to certbot to prevent hanging
            # if ! exec_command "Certbot SSL" "timeout 300s sudo certbot --nginx -d \"$NAMESERVERS\" --non-interactive --agree-tos -m \"$CERTBOT_EMAIL\" --redirect"; then
            if ! exec_command "Certbot SSL" "timeout 300s sudo certbot certonly --nginx $(for d in $NAMESERVERS; do echo -n "-d $d "; done) --non-interactive --agree-tos -m \"$CERTBOT_EMAIL\" --redirect --expand"; then
            # if ! exec_command "Certbot SSL" "timeout 300s sudo certbot certonly -a dns-multi --dns-multi-credentials=/etc/letsencrypt/dns-multi.ini -d \"*.${NAMESERVERS}\" -d \"${NAMESERVERS}\" -m \"${CERTBOT_EMAIL}\" --non-interactive --agree-tos"; then
              log_message "WARN" "‚ö†Ô∏è Certbot SSL generation may have issues, but continuing with deployment"
            fi

            # Final NGINX test & reload
            log_message "INFO" "Testing final nginx config after certbot changes"
            if ! exec_command "NGINX config test post-certbot" "sudo nginx -t"; then
              exit 1
            fi

            log_message "INFO" "Reloading nginx configuration"
            if ! exec_command "NGINX final reload" "sudo nginx -s reload"; then
              exit 1
            fi

            # Clean up old container
            log_message "INFO" "Stopping the old Docker container"
            if [ "$CURRENT_PORT" == "3001" ]; then
              exec_command "Remove old Blue container" "docker rm -f Blue" || log_message "WARN" "‚ö†Ô∏è Failed to remove old Blue container (might not exist)"
            else
              exec_command "Remove old Green container" "docker rm -f Green" || log_message "WARN" "‚ö†Ô∏è Failed to remove old Green container (might not exist)"
            fi

            # Cleanup Docker images
            log_message "INFO" "Pruning unused Docker images and containers older than 72 hours"
            if ! exec_command "Docker pruning" "docker system prune -af --filter \"until=72h\""; then
              log_message "WARN" "‚ö†Ô∏è Docker pruning had issues but deployment completed"
            fi

            # ==============================================
            # DATABASE ROLLBACK MECHANISM (if IS_ROLLBACK is true)
            # ==============================================
            if [ "$IS_ROLLBACK" = "true" ]; then
              log_message "INFO" "==== STARTING DATABASE ROLLBACK ===="
              log_message "INFO" "‚Ü©Ô∏è Starting rollback to commit $GIT_HASH from branch $BRANCH_NAME"

              # Create rollback directories
              if ! exec_command "Create rollback directories" "mkdir -p /tmp/rollback_migrations /tmp/latest_migrations"; then
                exit 1
              fi

              # Change to repo directory for git operations
              cd ~/onehash-cal || { log_message "ERROR" "Failed to cd into ~/onehash-cal for rollback"; exit 1; }

              # Update sparse-checkout to include migrations
              log_message "INFO" "Updating sparse-checkout to include migrations"
              if ! exec_command "Update sparse-checkout for migrations" "echo 'packages/prisma/migrations/*' > .git/info/sparse-checkout"; then
                exit 1
              fi

              # Fetch all necessary commits
              log_message "INFO" "üì¶ Fetching commits for rollback..."
              if ! exec_command "Git fetch for rollback" "git fetch origin $BRANCH_NAME"; then
                exit 1
              fi

              # Get latest commit
              LATEST_COMMIT=$(git rev-parse origin/$BRANCH_NAME 2>>"$LOG_FILE")
              if [ $? -ne 0 ]; then
                log_message "ERROR" "‚ùå Could not determine latest commit from $BRANCH_NAME"
                exit 1
              fi
              log_message "INFO" "‚úÖ Latest commit on $BRANCH_NAME is $LATEST_COMMIT"

              # Checkout migrations from latest commit
              log_message "INFO" "üîç Checking out migrations from latest commit"
              if ! exec_command "Create latest checkout dir" "mkdir -p /tmp/latest-checkout"; then
                exit 1
              fi

              if ! exec_command "Checkout latest migrations" "git --work-tree=/tmp/latest-checkout checkout $LATEST_COMMIT -- packages/prisma/migrations"; then
                log_message "ERROR" "‚ùå Could not checkout migrations from latest commit $LATEST_COMMIT"
                exit 1
              fi

              if ! exec_command "Copy latest migrations" "cp -r /tmp/latest-checkout/packages/prisma/migrations/* /tmp/latest_migrations/ 2>/dev/null || true"; then
                log_message "WARN" "‚ö†Ô∏è No migrations found in latest commit or copy failed"
              fi

              if ! exec_command "Cleanup latest checkout" "rm -rf /tmp/latest-checkout"; then
                log_message "WARN" "‚ö†Ô∏è Could not cleanup latest checkout directory"
              fi

              # Checkout migrations from rollback commit
              log_message "INFO" "üîç Checking out migrations from rollback commit $GIT_HASH"
              if ! exec_command "Create rollback checkout dir" "mkdir -p /tmp/rollback-checkout"; then
                exit 1
              fi

              if ! exec_command "Checkout rollback migrations" "git --work-tree=/tmp/rollback-checkout checkout $GIT_HASH -- packages/prisma/migrations"; then
                log_message "ERROR" "‚ùå Could not checkout migrations from rollback commit $GIT_HASH"
                exit 1
              fi

              if ! exec_command "Copy rollback migrations" "cp -r /tmp/rollback-checkout/packages/prisma/migrations/* /tmp/rollback_migrations/ 2>/dev/null || true"; then
                log_message "WARN" "‚ö†Ô∏è No migrations found in rollback commit or copy failed"
              fi

              if ! exec_command "Cleanup rollback checkout" "rm -rf /tmp/rollback-checkout"; then
                log_message "WARN" "‚ö†Ô∏è Could not cleanup rollback checkout directory"
              fi

              # Compare migrations and find new ones to rollback
              log_message "INFO" "üîÅ Comparing migrations..."
              NEW_MIGRATIONS_FILE="/tmp/new_migrations_list.txt"
              
              if ! exec_command "Compare migrations" "comm -13 <(ls /tmp/rollback_migrations 2>/dev/null | sort) <(ls /tmp/latest_migrations 2>/dev/null | sort) | sort -r > $NEW_MIGRATIONS_FILE"; then
                log_message "ERROR" "‚ùå Failed to compare migrations"
                exit 1
              fi

              # Check if there are migrations to rollback
              if [ ! -s "$NEW_MIGRATIONS_FILE" ]; then
                log_message "INFO" "‚úÖ No new migrations to rollback"
              else
                log_message "INFO" "‚è¨ Migrations to rollback:"
                cat "$NEW_MIGRATIONS_FILE" >> "$LOG_FILE"

                # Check if psql is available
                if ! command -v psql >/dev/null 2>&1; then
                  log_message "ERROR" "‚ùå PostgreSQL client (psql) is not installed"
                  exit 1
                fi

                # Test database connection
                log_message "INFO" "Testing database connection..."
                if ! exec_command "Test DB connection" "timeout 30s psql \"$DATABASE_URL\" -c 'SELECT 1;' > /dev/null 2>&1"; then
                  log_message "ERROR" "‚ùå Could not connect to database"
                  exit 1
                fi

                # Process each migration for rollback
                while IFS= read -r mig; do
                  if [ -z "$mig" ]; then
                    continue
                  fi

                  MIG_DIR="/tmp/latest_migrations/$mig"
                  DOWN_SQL="$MIG_DIR/down.sql"

                  log_message "INFO" "üîÅ Rolling back migration: $mig"

                  if [ ! -f "$DOWN_SQL" ]; then
                    log_message "ERROR" "‚ùå down.sql not found for $mig, skipping."
                    continue
                  fi

                  # Execute down.sql
                  log_message "INFO" "‚ñ∂Ô∏è Running down.sql for $mig..."
                  if ! exec_command "Execute down.sql for $mig" "timeout 300s psql \"$DATABASE_URL\" -v ON_ERROR_STOP=1 -f \"$DOWN_SQL\""; then
                    log_message "ERROR" "‚ùå Failed executing down.sql for $mig"
                    exit 1
                  fi

                  # Delete migration record from _prisma_migrations
                  log_message "INFO" "üßπ Deleting $mig from _prisma_migrations..."
                  if ! exec_command "Delete migration record for $mig" "timeout 60s psql \"$DATABASE_URL\" -c \"DELETE FROM _prisma_migrations WHERE migration_name = '$mig';\""; then
                    log_message "ERROR" "‚ùå Failed to delete $mig from _prisma_migrations"
                    exit 1
                  fi

                  log_message "INFO" "‚úÖ Successfully rolled back $mig"
                done < "$NEW_MIGRATIONS_FILE"

                log_message "INFO" "‚úÖ Database rollback completed successfully"
              fi

              # Cleanup rollback files
              if ! exec_command "Cleanup rollback files" "rm -rf /tmp/rollback_migrations /tmp/latest_migrations $NEW_MIGRATIONS_FILE"; then
                log_message "WARN" "‚ö†Ô∏è Could not cleanup rollback temporary files"
              fi

              log_message "INFO" "==== DATABASE ROLLBACK COMPLETED ===="
            else
              log_message "INFO" "üîÑ Skipping database rollback (not a rollback deployment)"
            fi

            log_message "INFO" "‚úÖ == Deployment Completed Successfully =="

            # Output log summary at the end for GitHub Actions logs
            echo "========= DEPLOYMENT LOG SUMMARY ========="
            grep -E "ERROR|WARN" "$LOG_FILE" || echo "No errors or warnings found in deployment"
            echo "======================================="

            # Exit with success status
            exit 0
    
      # APPENDING EC2 LOG FILE INTO CURRENT RUNNER LOGFILE
      - name: Copy VPC logs to runner environment
        uses: nicklasfrahm/scp-action@main
        if: always()
        id : download_vpc_logs
        env:
          EC2_HOST: ${{ steps.key_values.outputs.EC2_HOST }}
          EC2_SSH_KEY: ${{ steps.key_values.outputs.EC2_SSH_KEY }}
        with:
          direction:  download
          host: ${{ env.EC2_HOST }}

          fingerprint: ${{ secrets.SSH_TARGET_FINGERPRINT }}
          insecure_ignore_fingerprint : true
          
          username: "ubuntu"
          key: ${{ env.EC2_SSH_KEY }}
          source: '/home/ubuntu/deployment.log'
          target: './deployment.log'

      - name: Append VPC logs to runner log file
        if: ${{ steps.download_vpc_logs.outcome == 'success'}}
        env:
          LOG_FILE: ${{ env.LOG_FILE }}
        run: |
          [ -f ./deployment.log ] && cat ./deployment.log >> "$LOG_FILE"

      
      # NOTIFY LOGS ACTION
      - name: Send deployment status email
        if: always()
        env:
          SENDGRID_API_KEY: ${{ secrets.SENDGRID_API_KEY }}
          EMAIL_TO: ${{ secrets.EMAIL_TO}}
          EMAIL_FROM: ${{secrets.EMAIL_FROM}}
          LOG_FILE: ${{ env.LOG_FILE }}
          ENVIRONMENT: ${{ steps.set_branch.outputs.branch_name == 'deploy' && 'PRODUCTION' || 'STAGING' }}
        run: |

          LOG_SNIPPET=$(cat "$LOG_FILE" | jq -Rs .)
          echo "LOG_SNIPPET $LOG_SNIPPET"
          SUBJECT="CAL ID $ENVIRONMENT Deployment Status "
          BODY=$(jq -Rs --arg sha "${{ github.sha }}" \
                  --arg status "$([ '${{ job.status }}' = 'success' ] && echo 'Successful' || echo 'Failed')" \
                  --arg actor "${{ github.actor }}" \
                  --arg branch "${{ github.ref_name }}" \
                  --arg runid "${{ github.run_id }}" \
                  --arg logs "$LOG_SNIPPET" '
                  "‚úÖ DEPLOYMENT Notification\n\nCommit: \($sha)\nStatus: \($status)\nUser: \($actor)\nBranch: \($branch)\n\nLogs: https://github.com/${{ github.repository }}/actions/runs/\($runid)\n\n--- Workflow Log Snippet ---\n\($logs | fromjson)"
                ' <<< "")

          echo "Log_body $BODY"

          curl --request POST \
            --url https://api.sendgrid.com/v3/mail/send \
            --header "Authorization: Bearer $SENDGRID_API_KEY" \
            --header 'Content-Type: application/json' \
            --data @- <<EOF
            {
              "personalizations": [
                {
                  "to": [
                    {
                      "email": "${EMAIL_TO}"
                    }
                  ]
                }
              ],
              "from": {
                "email": "${EMAIL_FROM}"
              },
              "subject": "${SUBJECT}",
              "content": [
                {
                  "type": "text/plain",
                  "value": $BODY
                }
              ]
            }
          EOF

          echo "Email sent successfully!"
