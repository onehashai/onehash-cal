name: Build, Push Docker Image, Deploy to EC2

on:
  push:
    branches:
      - deploy
  pull_request:
    types:
      - closed  
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      branch:
        description: "Target branch"
        required: false
        default: "develop"
      git_hash:
        description: "Override Git commit hash"
        required: false
        default: ""

concurrency:
  group: ${{ github.workflow }}

jobs:
  # ONLY RUN JOB ON PR MERGE on MAIN OR DEVELOP BRANCH
  build-push-deploy:
    if: github.event.pull_request.merged == true || github.event_name == 'workflow_dispatch' || github.ref == 'refs/heads/deploy'
    runs-on: ubuntu-latest      

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1 # Fetch only the latest commit to speed up the process

      - name: Initialize Global Log File
        run: |
          echo "LOG_FILE=workflow.log" >> $GITHUB_ENV
          echo "Logging started" > workflow.log
      
      - name: Check for required secrets
        id: check_required_secrets_status
        run: |
          check() {
            if [ -z "$1" ]; then
              echo "$2 is EMPTY âŒ" | tee -a $LOG_FILE
              echo "passed=failure" >> $GITHUB_OUTPUT
            else
              echo "$2 is SET âœ…"
            fi
          }
          check "${{ secrets.DOMAIN_NAME_STAG }}" "DOMAIN_NAME_STAG"
          check "${{ secrets.EC2_HOST_STAG }}" "EC2_HOST_STAG"
          check "${{ secrets.EC2_SSH_KEY_STAG }}" "EC2_SSH_KEY_STAG"
          check "${{ secrets.DATABASE_DIRECT_URL_STAG}}" "DATABASE_DIRECT_URL_STAG"
          check "${{ secrets.DOMAIN_NAME_PROD }}" "DOMAIN_NAME_PROD"
          check "${{ secrets.EC2_HOST_PROD }}" "EC2_HOST_PROD"
          check "${{ secrets.EC2_SSH_KEY_PROD }}" "EC2_SSH_KEY_PROD"
          check "${{ secrets.DATABASE_DIRECT_URL_PROD}}" "DATABASE_DIRECT_URL_PROD"
          check "${{ secrets.AWS_REGION }}" "AWS_REGION"
          check "${{ secrets.AWS_ACCESS_KEY_ID }}" "AWS_ACCESS_KEY_ID"
          check "${{ secrets.AWS_SECRET_ACCESS_KEY }}" "AWS_SECRET_ACCESS_KEY"
          check "${{ secrets.REPO_NAME }}" "REPO_NAME"
          check "${{ secrets.REPO_URL }}" "REPO_URL"
          check "${{ secrets.AWS_ACCOUNT_ID }}" "AWS_ACCOUNT_ID"
          check "${{ secrets.CERTBOT_EMAIL }}" "CERTBOT_EMAIL"
          check "${{ secrets.NEXTAUTH_SECRET }}" "NEXTAUTH_SECRET"
          check "${{ secrets.CALENDSO_ENCRYPTION_KEY }}" "CALENDSO_ENCRYPTION_KEY"
          check "${{ secrets.NEXT_PUBLIC_API_V2_URL }}" "NEXT_PUBLIC_API_V2_URL"
          check "${{ secrets.SENDGRID_API_KEY }}" "SENDGRID_API_KEY"
          check "${{ secrets.EMAIL_TO }}" "EMAIL_TO"
          check "${{ secrets.EMAIL_FROM }}" "EMAIL_FROM"
          
      # SETTING NECESSARY ENV VARIABLES
      - name: Extract Git commit hash
        if: ${{ steps.check_required_secrets_status.outputs.passed != 'failure' }}
        id: hash
        run: |
          if [ -n "${{ github.event.inputs.git_hash }}" ]; then
            hash="${{ github.event.inputs.git_hash }}"
          else
            hash="$(git rev-parse HEAD)"
          fi
          echo "GIT_HASH=$hash" >> $GITHUB_OUTPUT
        
      - name: Set environment variables based on branch
        if: ${{ steps.check_required_secrets_status.outputs.passed != 'failure' }}
        env:
          BRANCH_NAME: ${{ github.event.inputs.branch != '' && github.event.inputs.branch || github.ref_name }}
          IMAGE_TAG: ${{ env.BRANCH_NAME == 'main' && 'latest-prod' || 'latest-stag' }}
        run: |         
          echo "BRANCH=$BRANCH_NAME" >> $GITHUB_ENV
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV

      # BUILDING AND PUSHING DOCKER IMAGE
      - name: Set up Docker Buildx
        id: setup_docker
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS Credentials
        if: ${{ steps.setup_docker.outcome == 'success' }}
        uses: aws-actions/configure-aws-credentials@v1
        id: configure-aws
        continue-on-error: true
        with:
          aws-region: ${{ secrets.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Check AWS Configure status
        shell: bash
        run: |
          if [ "${{ steps.configure-aws.outcome }}" != "success" ]; then
            echo "[ERROR]: âŒ AWS Configure failed" >> "$LOG_FILE"
          else
            echo "[INFO]: âœ… AWS Configure successful" >> "$LOG_FILE"
          fi

      - name: Login to Amazon ECR
        if: ${{ steps.configure-aws.outcome == 'success' && !(github.event_name == 'workflow_dispatch' && github.event.inputs.git_hash != '') }}
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
        continue-on-error: true

      - name: Check ECR login status
        shell: bash
        if: ${{ steps.configure-aws.outcome == 'success' && !(github.event_name == 'workflow_dispatch' && github.event.inputs.git_hash != '') }}
        run: |
          if [ "${{ steps.login-ecr.outcome }}" != "success" ]; then
            echo "[ERROR]: âŒ ECR login failed" >> "$LOG_FILE"
          else
            echo "[INFO]: âœ… ECR login successful" >> "$LOG_FILE"
            echo "passed=success" >> $GITHUB_OUTPUT
          fi

      - name: Set Docker tag suffix
        if: ${{ steps.login-ecr.outcome == 'success' && !(github.event_name == 'workflow_dispatch' && github.event.inputs.git_hash != '') }}
        id: tag
        run: |
          echo "tag_suffix=${{ github.event.inputs.branch == 'main' && 'latest-prod' || 'latest-stag' }}" >> $GITHUB_OUTPUT


      - name: Build and Push Docker image
        if: ${{ steps.login-ecr.outcome == 'success' && !(github.event_name == 'workflow_dispatch' && github.event.inputs.git_hash != '') }}
        id: docker_build
        uses: docker/build-push-action@v5
        continue-on-error: true
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ secrets.REPO_NAME }}:${{ steps.hash.outputs.git_hash }}
            ${{ steps.login-ecr.outputs.registry }}/${{ secrets.REPO_NAME }}:${{ steps.tag.outputs.tag_suffix }}
          build-args: |
            NEXTAUTH_URL=${{ github.event.inputs.branch == 'main' && secrets.DOMAIN_NAME_PROD || secrets.DOMAIN_NAME_STAG }}
            NEXTAUTH_SECRET=${{ secrets.NEXTAUTH_SECRET }}
            CALENDSO_ENCRYPTION_KEY=${{ secrets.CALENDSO_ENCRYPTION_KEY }}
            NEXT_PUBLIC_WEBAPP_URL=${{ format('https://{0}', github.event.inputs.branch == 'main' && secrets.DOMAIN_NAME_PROD || secrets.DOMAIN_NAME_STAG) }}
            NEXT_PUBLIC_API_V2_URL=${{ secrets.NEXT_PUBLIC_API_V2_URL }}

      - name: Check Docker build status
        shell: bash
        id : check_docker_build_status
        if: ${{ steps.login-ecr.outcome == 'success' && !(github.event_name == 'workflow_dispatch' && github.event.inputs.git_hash != '') }}
        run: |
          if [ "${{ steps.docker_build.outcome }}" != "success" ]; then
            echo "[ERROR]: âŒ Docker build & push failed" >> "$LOG_FILE"
          else
            echo "[INFO]: âœ… Docker build & push succeeded" >> "$LOG_FILE"
          fi

      - name: ROLLBACK CHECK
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.git_hash != '' }}
        run: |
          echo "[INFO]: â†©ï¸ Rollback step: Skipping building docker images" >> "$LOG_FILE"
          
      # DEPLOYING TO EC2
      - name: SSH into EC2 and Deploy
        if: ${{ steps.docker_build.outcome == 'success' }}
        uses: appleboy/ssh-action@v0.1.10
        id: ssh_deploy
        env:
          DOMAIN_NAME: ${{github.event.inputs.branch == 'main' && secrets.DOMAIN_NAME_PROD || secrets.DOMAIN_NAME_STAG }}
          EC2_HOST: ${{ github.event.inputs.branch == 'main' && secrets.EC2_HOST_PROD || secrets.EC2_HOST_STAG }}
          EC2_SSH_KEY: ${{ github.event.inputs.branch == 'main' && secrets.EC2_SSH_PROD || secrets.EC2_SSH_KEY_STAG }}
          REPO_URL: ${{secrets.REPO_URL}}
          BRANCH_NAME: ${{ github.event.inputs.branch != '' && github.event.inputs.branch || github.ref_name }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          REPO_NAME: ${{ secrets.REPO_NAME }}
          CERTBOT_EMAIL: ${{ secrets.CERTBOT_EMAIL }}
          GIT_HASH: ${{ steps.hash.outputs.git_hash }}
          IS_ROLLBACK: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.git_hash != '' }}
        with:
          host: ${{ env.EC2_HOST }}
          username: "ubuntu"
          key: ${{ env.EC2_SSH_KEY }}
          command_timeout: 1500s # 25 minutes
          envs: DOMAIN_NAME, AWS_REGION, AWS_ACCOUNT_ID, REPO_NAME, REPO_URL, BRANCH_NAME, AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, CERTBOT_EMAIL, GIT_HASH ,IS_ROLLBACK
          script: |
            #!/bin/bash

            #Initialize log file 
            LOG_FILE="/home/ubuntu/deployment.log"
            : > "$LOG_FILE"

            # Function for logging with timestamp
            log_message() {
              local level=$1
              local message=$2
              echo "[VPC][$level] $message" >> "$LOG_FILE"
              # Echo to stdout for GitHub Actions logs
              echo "[$level] $message"
            }

            # Function to execute a command and check its status
            exec_command() {
              local command_name=$1
              shift
              local command_to_run="$1"

              log_message "INFO" "Executing: $command_name"
              log_message "DEBUG" "Command: $command_to_run"

              eval "$command_to_run"
              local status=$?

              if [ $status -ne 0 ]; then
                log_message "ERROR" "âŒ $command_name failed with status $status"
                return 1
              else
                log_message "INFO" "âœ… $command_name completed successfully"
                return 0
              fi
            }

            log_message "INFO" "==VPC LOGS =="

            # Setting up onehash-cal repo locally and pulling the latest changes
            if [ ! -d "$HOME/onehash-cal" ]; then
              log_message "INFO" "Directory 'onehash-cal' does not exist. Cloning the repository."
              mkdir -p ~/onehash-cal
              cd ~/onehash-cal || { log_message "ERROR" "Failed to cd into ~/onehash-cal"; exit 1; }
              
              if ! exec_command "Git init" "git init"; then
                exit 1
              fi
              
              exec_command "Git sparse checkout setup" "git config core.sparseCheckout true"
              # PULLING ONLY THE "infra" DIRECTORY TO SAVE TIME/SPACE
              echo "infra/*" >> .git/info/sparse-checkout

              # ADDING THE REMOTE REPO
              if ! exec_command "Git remote add" "git remote add origin ${{env.REPO_URL}}"; then
                exit 1
              fi
              
              # Fetch the branch explicitly rather than pull
              if ! exec_command "Git fetch" "git fetch origin ${{env.BRANCH_NAME}} --depth=1"; then
                exit 1
              fi
              
              if ! exec_command "Git checkout" "git checkout ${{env.BRANCH_NAME}}"; then
                exit 1
              fi
            else
              log_message "INFO" "Directory 'onehash-cal' exists. Pulling the latest changes."
              cd ~/onehash-cal || { log_message "ERROR" "Failed to cd into ~/onehash-cal"; exit 1; }
              
              # Fetch changes first to see what's new
              if ! exec_command "Git fetch" "git fetch origin ${{env.BRANCH_NAME}}"; then
                exit 1
              fi
              
              # Reset to the remote branch to avoid merge conflicts
              if ! exec_command "Git reset" "git reset --hard origin/${{env.BRANCH_NAME}}"; then
                exit 1
              fi
            fi

            # Set timeout for aws command to prevent hanging
            export AWS_CLI_TIMEOUT=60
            export AWS_SDK_TIMEOUT=60

            # Login to AWS ECR with timeout
            log_message "INFO" "Logging into AWS ECR..."
            if ! exec_command "AWS ECR Login" "timeout 60s aws ecr get-login-password --region \"${AWS_REGION}\" | timeout 60s docker login --username AWS --password-stdin \"${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com\" >> \"$LOG_FILE\" 2>&1"; then
              log_message "ERROR" "Failed to log into ECR - exiting deployment"
              exit 1
            else
              log_message "INFO" "Logged into ECR successfully."
            fi

            # Determine current and new ports
            PORT=$(sudo grep -oP '127.0.0.1:\K[0-9]+' /etc/nginx/conf.d/default.conf 2>/dev/null || echo "")
            if [ -z "$PORT" ]; then
              CURRENT_PORT=3001
            else
              CURRENT_PORT=$PORT
            fi
            log_message "INFO" "Current port: $CURRENT_PORT"

            # BLUE/GREEN DEPLOYMENT STRATEGY
            # Check the current port and switch to the other one
            if [ "$CURRENT_PORT" = "3001" ]; then
              NEW_PORT=3002
              CONTAINER_NAME=Green
              log_message "INFO" "Switching to port 3002(Green)"
            else
              NEW_PORT=3001
              CONTAINER_NAME=Blue
              log_message "INFO" "Switching to port 3001(Blue)"
            fi

            # Build the Docker image with the new port
            log_message "INFO" "Building Docker image with new port: $NEW_PORT"
            cd ~/onehash-cal/infra/docker/web || { log_message "ERROR" "Failed to cd into ~/onehash-cal/infra/docker/web"; exit 1; }

            if [ ! -d "$HOME/onehash-cal/infra/docker/web" ]; then
              log_message "ERROR" "Directory 'onehash-cal/infra/docker/web' does not exist. Exiting."
              exit 1
            fi

            # Stop and remove any existing container with the same name
            docker rm -f "$CONTAINER_NAME" >/dev/null 2>&1 || true
            log_message "INFO" "Removed any existing container with name $CONTAINER_NAME"

            #Running container
            log_message "INFO" "Starting Docker container '$CONTAINER_NAME' on port $NEW_PORT"

            AWS_ACCOUNT_ID=${{ env.AWS_ACCOUNT_ID }}
            AWS_REGION=${{ env.AWS_REGION }}
            REPO_NAME=${{ env.REPO_NAME }}
            DOCKER_IMAGE_TAG=${{ env.GIT_HASH }}
            IS_ROLLBACK=${{ env.IS_ROLLBACK}}

            if ! exec_command "Docker run" "docker run -d -it -e IS_ROLLBACK=\"$IS_ROLLBACK"\ --name \"$CONTAINER_NAME\" --env-file \"$HOME/.env\" -p ${NEW_PORT}:3001 --add-host=host.docker.internal:host-gateway \"${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${REPO_NAME}:${DOCKER_IMAGE_TAG}\""; then
              log_message "ERROR" "âŒ Failed to start Docker container '$CONTAINER_NAME' - aborting deployment"
              exit 1
            else
              log_message "INFO" "âœ… Docker container '$CONTAINER_NAME' started successfully on port $NEW_PORT"
            fi

            # HEALTH CHECK with progress tracking and better error handling
            log_message "INFO" "Starting health checks for application on port $NEW_PORT"
            HEALTH_CHECK_SUCCESS=false

            for i in {1..30}; do
              log_message "INFO" "Health check attempt $i/30"
              
              # Use timeout for curl to prevent hanging
              STATUS_CODE=$(timeout 10s curl -s -o /dev/null -w "%{http_code}" "http://localhost:${NEW_PORT}/api/health" || echo "FAILED")
              
              if [ "$STATUS_CODE" = "200" ]; then
                log_message "INFO" "âœ… Application is healthy! Status code: $STATUS_CODE"
                HEALTH_CHECK_SUCCESS=true
                break
              fi
              log_message "WARN" "â³ Still waiting... Attempt $i/30 - Status code: $STATUS_CODE"
              sleep 30
            done
              
            if [ "$HEALTH_CHECK_SUCCESS" != "true" ]; then
              log_message "ERROR" "âŒ Application did not become healthy after 30 attempts. Checking container logs..."
              docker logs "$CONTAINER_NAME" >> "$LOG_FILE" 2>&1
              log_message "ERROR" "Deployment failed - application didn't pass health checks"
              exit 1
            fi

            # NGINX configuration
            log_message "INFO" "Configuring NGINX"

            NGINX_CONF_PATH="/etc/nginx/conf.d/default.conf"
            TEMPLATE_PATH="$HOME/onehash-cal/infra/docker/web/nginx.template.conf"

            # Check if template exists
            if [ ! -f "$TEMPLATE_PATH" ]; then
              log_message "ERROR" "âŒ NGINX template not found at $TEMPLATE_PATH"
              exit 1
            fi

            # Remove default site
            log_message "INFO" "Removing default NGINX site (if any)"
            if ! exec_command "Removing default site" "sudo rm -f /etc/nginx/sites-enabled/default"; then
              log_message "WARN" "âš ï¸ Could not remove default site, continuing anyway"
            fi

            # Copy template
            log_message "INFO" "Copying nginx template to $NGINX_CONF_PATH"
            if ! exec_command "Copy nginx config" "sudo cp -f \"$TEMPLATE_PATH\" \"$NGINX_CONF_PATH\""; then
              log_message "ERROR" "Failed to copy NGINX config template"
              exit 1
            fi

            # Replace placeholders
            log_message "INFO" "Replacing 'PORT_PLACEHOLDER' and 'DOMAIN_PLACEHOLDER'"
            if ! exec_command "Replace PORT" "sudo sed -i \"s/PORT_PLACEHOLDER/$NEW_PORT/g\" \"$NGINX_CONF_PATH\""; then
              exit 1
            fi

            if ! exec_command "Replace DOMAIN" "sudo sed -i \"s/DOMAIN_PLACEHOLDER/$DOMAIN_NAME/g\" \"$NGINX_CONF_PATH\""; then
              exit 1
            fi

            # Test NGINX config
            log_message "INFO" "Testing NGINX config before reload"
            if ! exec_command "NGINX config test" "sudo nginx -t"; then
              log_message "ERROR" "NGINX configuration test failed"
              exit 1
            fi

            # Reload NGINX
            log_message "INFO" "Reloading NGINX (pre-certbot)"
            if ! exec_command "NGINX reload" "sudo nginx -s reload"; then
              exit 1
            fi

            # SSL Certificate with certbot
            log_message "INFO" "Generating SSL cert for $DOMAIN_NAME"
            # Add a timeout to certbot to prevent hanging
            if ! exec_command "Certbot SSL" "timeout 300s sudo certbot --nginx -d \"$DOMAIN_NAME\" --non-interactive --agree-tos -m \"$CERTBOT_EMAIL\" --redirect"; then
              log_message "WARN" "âš ï¸ Certbot SSL generation may have issues, but continuing with deployment"
            fi

            # Final NGINX test & reload
            log_message "INFO" "Testing final nginx config after certbot changes"
            if ! exec_command "NGINX config test post-certbot" "sudo nginx -t"; then
              exit 1
            fi

            log_message "INFO" "Reloading nginx configuration"
            if ! exec_command "NGINX final reload" "sudo nginx -s reload"; then
              exit 1
            fi

            # Clean up old container
            log_message "INFO" "Stopping the old Docker container"
            if [ "$CURRENT_PORT" == "3001" ]; then
              exec_command "Remove old Blue container" "docker rm -f Blue" || log_message "WARN" "âš ï¸ Failed to remove old Blue container (might not exist)"
            else
              exec_command "Remove old Green container" "docker rm -f Green" || log_message "WARN" "âš ï¸ Failed to remove old Green container (might not exist)"
            fi

            # Cleanup Docker images
            log_message "INFO" "Pruning unused Docker images and containers older than 72 hours"
            if ! exec_command "Docker pruning" "docker system prune -af --filter \"until=72h\""; then
              log_message "WARN" "âš ï¸ Docker pruning had issues but deployment completed"
            fi

            log_message "INFO" "âœ… == Deployment Completed Successfully =="

            # Output log summary at the end for GitHub Actions log
            echo "========= DEPLOYMENT LOG SUMMARY ========="
            grep -E "ERROR|WARN" "$LOG_FILE" || echo "No errors or warnings found in deployment"
            echo "======================================="

      - name: Rollback new Prisma migrations (with logging)
        if: ${{ steps.ssh_deploy.outcome == 'success' && (github.event_name == 'workflow_dispatch' && github.event.inputs.git_hash != '') }}
        env:
          BRANCH: ${{ github.event.inputs.branch != '' && github.event.inputs.branch || github.ref_name }}
          DATABASE_URL: ${{ env.BRANCH == 'main' && secrets.DATABASE_DIRECT_URL_PROD || secrets.DATABASE_DIRECT_URL_STAG }}
          ROLLBACK_COMMIT: ${{ github.event.inputs.git_hash }}
        run: |
          set -e
      
          echo "[INFO]: â†©ï¸ Starting rollback to commit $ROLLBACK_COMMIT from branch $BRANCH" >> "$LOG_FILE"
      
          mkdir -p rollback_migrations latest_migrations
      
          echo "[INFO]: ðŸ“¦ Fetching commits..." >> "$LOG_FILE"
          git fetch origin $BRANCH || { echo "[ERROR]: âŒ Failed to fetch branch $BRANCH" >> "$LOG_FILE"; exit 1; }
      
          LATEST_COMMIT=$(git rev-parse origin/$BRANCH 2>>"$LOG_FILE") || {
            echo "[ERROR]: âŒ Could not determine latest commit from $BRANCH" >> "$LOG_FILE"
            exit 1
          }
          echo "[INFO]: âœ… Latest commit on $BRANCH is $LATEST_COMMIT" >> "$LOG_FILE"
      
          echo "[INFO]: ðŸ” Checking out sparse migrations directory from latest commit..." >> "$LOG_FILE"
          mkdir latest-checkout
          git --work-tree=latest-checkout sparse-checkout set packages/prisma/migrations || {
            echo "[ERROR]: âŒ Sparse-checkout setup failed for latest commit" >> "$LOG_FILE"; exit 1;
          }
          git --work-tree=latest-checkout checkout $LATEST_COMMIT -- packages/prisma/migrations || {
            echo "[ERROR]: âŒ Could not checkout migrations from latest commit $LATEST_COMMIT" >> "$LOG_FILE"; exit 1;
          }
          cp -r latest-checkout/packages/prisma/migrations/* latest_migrations/
          rm -rf latest-checkout
          echo "[INFO]: âœ… Fetched latest migrations" >> "$LOG_FILE"
      
          echo "[INFO]: ðŸ” Checking out sparse migrations directory from rollback commit $ROLLBACK_COMMIT..." >> "$LOG_FILE"
          mkdir rollback-checkout
          git --work-tree=rollback-checkout sparse-checkout set packages/prisma/migrations || {
            echo "[ERROR]: âŒ Sparse-checkout setup failed for rollback commit" >> "$LOG_FILE"; exit 1;
          }
          git --work-tree=rollback-checkout checkout $ROLLBACK_COMMIT -- packages/prisma/migrations || {
            echo "[ERROR]: âŒ Could not checkout migrations from rollback commit $ROLLBACK_COMMIT" >> "$LOG_FILE"; exit 1;
          }
          cp -r rollback-checkout/packages/prisma/migrations/* rollback_migrations/
          rm -rf rollback-checkout
          echo "[INFO]: âœ… Fetched rollback migrations" >> "$LOG_FILE"
      
          echo "[INFO]: ðŸ” Comparing migrations..." >> "$LOG_FILE"
          comm -13 <(ls rollback_migrations | sort) <(ls latest_migrations | sort) | sort -r > new_migrations_list.txt
      
          if [ ! -s new_migrations_list.txt ]; then
            echo "[INFO]: âœ… No new migrations to rollback" >> "$LOG_FILE"
            exit 0
          fi
      
          echo "[INFO]: â¬ Migrations to rollback:" >> "$LOG_FILE"
          cat new_migrations_list.txt >> "$LOG_FILE"
      
          while read -r mig; do
            MIG_DIR="latest_migrations/$mig"
            DOWN_SQL="$MIG_DIR/down.sql"
      
            echo "[INFO]: ðŸ” Rolling back migration: $mig" >> "$LOG_FILE"
      
            if [ ! -f "$DOWN_SQL" ]; then
              echo "[ERROR]: âŒ down.sql not found for $mig, skipping." >> "$LOG_FILE"
              continue
            fi
      
            echo "[INFO]: â–¶ï¸ Running down.sql for $mig..." >> "$LOG_FILE"
            if ! psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f "$DOWN_SQL" >> "$LOG_FILE" 2>&1; then
              echo "[ERROR]: âŒ Failed executing down.sql for $mig" >> "$LOG_FILE"
              exit 1
            fi
      
            echo "[INFO]: ðŸ§¹ Deleting $mig from _prisma_migrations..." >> "$LOG_FILE"
            if ! psql "$DATABASE_URL" -c "DELETE FROM _prisma_migrations WHERE migration_name = '$mig';" >> "$LOG_FILE" 2>&1; then
              echo "[ERROR]: âŒ Failed to delete $mig from _prisma_migrations" >> "$LOG_FILE"
              exit 1
            fi
      
            echo "[INFO]: âœ… Successfully rolled back $mig" >> "$LOG_FILE"
          done < new_migrations_list.txt
      
          echo "[INFO]: âœ… Rollback completed successfully" >> "$LOG_FILE"
      

      # APPENDING EC2 LOG FILE INTO CURRENT RUNNER LOGFILE
      - name: Copy VPC logs to runner environment
        uses: nicklasfrahm/scp-action@main
        if: ${{ steps.docker_build.outcome == 'success' }}
        env:
          EC2_HOST: ${{ github.event.inputs.branch == 'main' && secrets.EC2_HOST_PROD || secrets.EC2_HOST_STAG }}
          EC2_SSH_KEY: ${{ github.event.inputs.branch == 'main' && secrets.EC2_SSH_PROD || secrets.EC2_SSH_KEY_STAG }}
        with:
          direction:  download
          host: ${{ env.EC2_HOST }}

          fingerprint: ${{ secrets.SSH_TARGET_FINGERPRINT }}
          insecure_ignore_fingerprint : true
          
          username: "ubuntu"
          key: ${{ env.EC2_SSH_KEY }}
          source: '/home/ubuntu/deployment.log'
          target: './deployment.log'
       
      # NOTIFY LOGS ACTION
      - name: Send deployment status email
        if: always()
        env:
          SENDGRID_API_KEY: ${{ secrets.SENDGRID_API_KEY }}
          EMAIL_TO: ${{ secrets.EMAIL_TO}}
          EMAIL_FROM: ${{secrets.EMAIL_FROM}}
          LOG_FILE: ${{ env.LOG_FILE }}
        run: |

          # Appending vpc logs to runner logs
          [ -f ./deployment.log ] && cat ./deployment.log >> "$LOG_FILE"

          LOG_SNIPPET=$(cat "$LOG_FILE" | jq -Rs .)
          echo "LOG_SNIPPET $LOG_SNIPPET"

          ENVIRONMENT=$([ "${{ github.event.inputs.branch }}" = "main" ] && echo "PRODUCTION" || echo "STAGING")
          SUBJECT="CAL ID $ENVIRONMENT Deployment Status "
          BODY=$(jq -Rs --arg sha "${{ github.sha }}" \
                  --arg status "$([ '${{ job.status }}' = 'success' ] && echo 'Successful' || echo 'Failed')" \
                  --arg actor "${{ github.actor }}" \
                  --arg branch "${{ github.ref_name }}" \
                  --arg runid "${{ github.run_id }}" \
                  --arg logs "$LOG_SNIPPET" '
                  "âœ… DEPLOYMENT Notification\n\nCommit: \($sha)\nStatus: \($status)\nUser: \($actor)\nBranch: \($branch)\n\nLogs: https://github.com/${{ github.repository }}/actions/runs/\($runid)\n\n--- Workflow Log Snippet ---\n\($logs | fromjson)"
                ' <<< "")

          echo "Log_body $BODY"

          curl --request POST \
            --url https://api.sendgrid.com/v3/mail/send \
            --header "Authorization: Bearer $SENDGRID_API_KEY" \
            --header 'Content-Type: application/json' \
            --data @- <<EOF
            {
              "personalizations": [
                {
                  "to": [
                    {
                      "email": "${EMAIL_TO}"
                    }
                  ]
                }
              ],
              "from": {
                "email": "${EMAIL_FROM}"
              },
              "subject": "${SUBJECT}",
              "content": [
                {
                  "type": "text/plain",
                  "value": $BODY
                }
              ]
            }
          EOF

          echo "Email sent successfully!"
